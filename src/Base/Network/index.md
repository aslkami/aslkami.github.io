## 网络分层的类型

- 应用层
  - 用户最终使用的接口，浏览器、qq、微信什么的都算
  - 会发送应用数据`报文`（浏览器那些请求响应头体）
  - 协议：`HTTP、DNS、FTP、TFTP、SMTP、DHCP`
- 表示层
  - 数据的表示、安全、压缩
- 会话层
  - 建立和管理会话的
- 传输层
  - 主要是提供安全及数据完整性保障，网络层不可靠，保证可靠的输出
  - `传输数据段 + 端口`, 包括传输层头部、应用层数据 + 端口
  - 协议：`TCP` 和 `UDP 协议`
- 网络层
  - 只要关心的是寻址，进行逻辑寻址，定位到对方，找到最短的路
  - `数据包 + IP`，包括网络层头部、传输层头部、应用层数据 + IP
  - 代表物理设备：路由器
  - 协议：`IP协议` 和 `ARP 协议`
- 数据链路层
  - 主要关心两个设备之间传递数据，建立逻辑链接，将数据组合成数据帧进行传递
  - `数据帧 + MAC地址`，包括帧头、网络层头部、传输层头部、应用层数据、帧尾 + MAC 地址
  - 代表物理设备：交换机
- 物理层
  - 核心是传输数据比特流，不关心具体的传输媒体

## 协议

### ARP 协议

会根据目的 ip 地址，解析目的 mac 地址

### DNS 协议

- 操作系统会对 DNS 解析的结果做缓存，如果缓存中有直接返回 IP 地址
- 会从 hosts 文件找对应的 IP 地址
- 会逐层 从 `.cn、.com` 的服务器将 ip 返回给 DNS 服务器，最终缓存 IP 地址

### UDP 协议（User Datagram Protocol）

- `UDP` 发出请求后，不考虑对方是否能接收到、内容是否完整、顺序是否正确，收到数据后也不会进行通知
- 首部结构简单，在数据传输时能实现最小的开销

### TCP 协议（Transmission Control Protocol）

- URG，紧急信号
- ACK，确认信号
- PSH，从 TCP 缓冲区读走数据
- RST，断开重连
- SYN，建立连接
- FIN，表示要断开

- 建立连接，三次握手

  - 客户端发送 SYNC 到服务器，此时 Seq=0
  - 服务器作出 ACK 应答，发送 SYNC 到客户端，此时 Seq=0， ACK=1
  - 客户端作出 ACK 应答，此时 ACK=1，Seq=1
  - **`如何记忆呢？`** 可以想象一下前后端联调的场景
    - 前端写完页面，然后发消息给服务端，说可以联调了
    - 服务端收到消息，然后说了句 好的，我这边准备好了，现在可以调了，你现在有空吗？（等前端确认，毕竟前端发了消息，可能去了趟厕所，不在工位上）
    - 前端回复收到，好的，我们开始联调吧～
    - 意思是双方都有空，都在线，才能交流下去

- 数据传输

  - 客户端发送 hello， PSH、ACK 主动给服务端推送数据，此时 Seq=1，ACK=1，len=5
  - 服务端收到消息，作出 ACK 应答，此时 Seq=1，ACK=6（上一次的 Seq + len）
  - 服务端给客户端发送 hi，PSH、ACK 服务端给客户端推送数据，此时 Seq=1，ACK=6，len=2
  - 客户端收到消息 hi，如果要传数据就会从 6 开始，此时 ACK=3（上一次的 Seq + len），Seq=6（上一次的 ACK）

- 断开连接，四次挥手

  - 客户端 FIN、ACK 断开，此时 Seq=6，ACK=3
  - 服务端 ACK 收到断开消息，此时 ACK=7，Seq=3
  - 服务端 FIN、ACK 要和客户端断开，此时 ACK=7，Seq=3
  - 客户端 ACK 收到断开消息，此时 ACK=4（上一次的 Seq + 1），Seq=7
  - **`如何记忆呢？`** 可以想象一下前后端联调完成后的场景
    - 前端联调测试完成，和客户端说测完了
    - 服务端收到消息，说好的，我也测一下（访问前端的页面体验体验）
    - 服务端测了根前端说没问题，那就联调完成了
    - 前端说好的，结束联调

## 滑动窗口

- TCP 是全双工的，所以发送端有发送缓存区；接收端有接收缓存区，要发送的数据都放 到发送者的缓存区，发送窗口（要被发送的数据）就是要发送缓存中的哪一部分
- 核心是流量控制：在建立连接时，接收端会告诉发送端自己的窗口大小（ rwnd ）,每次接收端收到数据后都会再次确认（ rwnd ）大小，如果值为 0，停止发送数据。（并发送窗口探测包，持续监测窗口大小）

## 粘包

Nagle 算法的基本定义是任意时刻，最多只能有一个未被确认的小段 (TCP 内部控制)，Cork 算法 当达到 MSS (Maximum Segment Size )值时统一进行发送（此值就是帧的大小 - ip 头 - tcp 头 = 1460 个字节）理论值

## TCP 弊端

- 队头阻塞，前面数据丢失，要等待数据传输回来，造成了拥堵
- 慢启动，每次传输数据丢失，都会建立连接，重复三次握手流程
- 短连接，端口会被占用

## HTTP

### 发展历程

- 1990 年 HTTP/0.9 为了便于服务器和客户端处理，采用了纯文本格式，只运行使用 GET 请求。在响应请求之后会立即关闭连接。
- 1996 年 HTTP/1.0 增强了 0.9 版本，引入了 HTTP Header（头部）的概念，传输的数据不再仅限于文本，可以解析图片音乐等，增加了响应状态码和 POST , HEAD 等请求方法。
- 1999 年广泛使用 HTTP/1.1 ，正式标准，允许持久连接，允许响应数据分块，增加了缓存管理和控制，增加了 PUT、DELETE 等新的方法。 (问题 多个请求并发 管线化 http 队头阻塞的问题)
- 2015 年 HTTP/2 ，使用 HPACK 算法压缩头部，减少数据传输量。允许服务器主动向客户端推送数据，二进制协议可发起多个请求，使用时需要对请求加密通信。
- 2018 年 HTTP/3 基于 UDP 的 QUIC 协议。

### HTTP/1.1

- HTTP/1.1 是可靠传输协议，基于 TCP/IP 协议；
- 采用应答模式，客户端主动发起请求，服务器被动回复请求；
- HTTP 是无状态的每个请求都是互相独立
- HTTP 协议的请求报文和响应报文的结构基本相同，由三部分组成

### 内容协商

| 客户端 Header  | 服务端 Header   |                                                           |
| :------------- | :-------------- | :-------------------------------------------------------- |
| Accept         | Content-Type    | 我发送给你的数据是什么类型                                |
| Acceptencoding | ContentEncoding | 我发送给你的数据是用什么格式压缩 ( gzip 、deflate 、 br ) |
| Acceptlanguage |                 | 根据客户端支持的语言返回 （多语言）                       |
| Range          | ContentRange    | 范围请求数据                                              |

### 长连接

TCP 的连接和关闭非常耗时间，所以我们可以复用 TCP 创建的连接。HTTP/1.1 响应中默认会增加 Connection:keep-alive

### 管线化

如果值创建一条 TCP 连接来进行数据的收发，就会变成 "串行" 模式，如果某个请求过慢就会发生阻塞问题。 Head-of-line blocking， HTTP/1.1 中采用了管线化的方式，对一个域名同时发起多个长连接实现并发。 默认 chrome 为 6 个。

> 同一个域名有限制，那么我就多开几个域名 域名分片

### Cookie

Set-Cookie/Cookie 用户第一次访问服务器的时候，服务器会写入身份标识，下次再请求的时候会携带 cookie 。通过 Cookie 可以实现有状态的会话

### HTTP 缓存

- 强缓存

  - 强缓存 服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应 header 中。
  - 强制缓存存在有效期，缓存期内不会向服务端发送请求。超过时间后需要去服务端验证是否是最新版本。
  - expired/cache-control：max-age
    - expired，客户端和服务端时间不一致，容易出问题
    - cache-control：max-age，采用相对时间

- 协商缓存（对比缓存）

  - if-Modified-Since/if-None-Match （最后修改时间）、 Last-modified/Etag (指纹)
  - 最后修改时间是秒级的，一秒内修改多次无法监控
  - 最后修改时间修改了，但是内容没有发生变化

### HTTPS

- https = http + ssl/tls, 主要的目的是提供数据的完整性和保密性。
- ssl => Secure Sockets Layer 安全套接层
- tls => Transport Layer Security 传输层安全

- 对称加密，加密和解密时使用的密钥都是同一个， 通信过程使用秘钥加密后的密文传输。只有自己和网站才能解密。

  > 目前 AES （Advanced Encryption Standard） ChaCha20 为最常见的对称加密算法

- 非对称加密，非对称加密可以解决“密钥交换”的问题。非对称加密有两个秘钥，公钥、私钥，所以称之为非对称。公钥加密私钥解密。

  > 并不能完全采用非对称加密算法，由于算法本身耗时远高于对称加密。

  - 最常听到的非对称加密算法是 RSA 、 ECC (子算法 ECDHE 用于密钥交换， ECDSA 用于数字签名)(性能和安全略胜一筹) HTTPS 中目前广泛使用 ECC 。

- 混合加密，通信刚开始的时候使用非对称算法，交换秘钥。在客户端生成会话秘钥后传送给服务端，后续通信采用对称加密的方式

  > 这里还并不安全，还涉及到中间人攻击。（ 指攻击者与通讯的两端分别创建独立的联系,并交换其所收到的数据 ）

- 数字证书和 CA, 因为谁都可以发布公钥，所以我们需要验证对方身份。防止中间人攻击

  > 客户端会判断有效期、颁发者、证书是否被修改及证书是否被吊销。 每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证。

  - 加密：对传输的数据进行加密。
  - 数据一致性：保证传输过程中数据不会被篡改。
  - 身份认证：确定对方的真实身份。

## `从输⼊ URL 到⻚⾯展⽰，这中间发⽣了什么？`

### 进程分类

- `浏览器进程`。主要负责界⾯显⽰、⽤⼾交互、⼦进程管理，同时提供存储等功能。
- `渲染进程`。核⼼任务是将 HTML、CSS 和 JavaScript 转换为⽤⼾可以与之交互的⽹⻚，排版引擎 Blink 和 JavaScript 引擎 V8 都是运⾏在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建⼀个渲染进程。出于安全考虑，渲染进程都是运⾏在沙箱模式下。
  - 因为渲染进程所有的内容都是通过⽹络获取的，会存在⼀些恶意代码利⽤浏览器漏洞对系统进⾏攻击，所以运⾏在渲染进程⾥⾯的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运⾏在安全沙箱⾥，就是为了保证系统的安全。
- `GPU 进程`。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。⽽ GPU 的使⽤初衷是为了实现 3D CSS 的效果，只是随后⽹⻚、Chrome 的 UI 界⾯都选择采⽤ GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引⼊了 GPU 进程。
- `⽹络进程`。主要负责⻚⾯的⽹络资源加载，之前是作为⼀个模块运⾏在浏览器进程⾥⾯的，直⾄最近才独⽴出来，成为⼀个单独的进程。
- `插件进程`。主要是负责插件的运⾏，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和⻚⾯造成影响。

### 流程

- ⾸先，⽤⼾从浏览器进程⾥输⼊请求信息；
- 然后，⽹络进程发起 URL 请求；
- 服务器响应 URL 请求之后，浏览器进程就⼜要开始准备渲染进程了；
- 渲染进程准备好之后，需要先向渲染进程提交⻚⾯数据，我们称之为提交⽂档阶段；
- 渲染进程接收完⽂档信息之后，便开始解析⻚⾯和加载⼦资源，完成⻚⾯的渲染。
  > 这其中，⽤⼾发出 URL 请求到⻚⾯开始解析的这个过程，就叫做导航。

`从输⼊URL到⻚⾯展⽰`

1. ⽤⼾输⼊

- 当⽤⼾在地址栏中输⼊⼀个查询关键字时，地址栏会判断输⼊的关键字是搜索内容，还是请求的 URL。
- 当浏览器刚开始加载⼀个地址之后，标签⻚上的图标便进⼊了加载状态。但此时⻚⾯显⽰的依然是之前打开的⻚⾯内容，并没⽴即替换为访问目标⻚⾯。因为需要等待提交⽂档阶段，⻚⾯内容才会被替换。

2. URL 请求过程

   接下来，便进⼊了⻚⾯资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送⾄⽹络进程，⽹络进程接收到 URL 请求后，会在这⾥发起真正的 URL 请求流程。那具体流程是怎样的呢？

   ⾸先，⽹络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进⼊⽹络请求流程。这请求前的第⼀步是要进⾏ DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建⽴ TLS 连接。

   接下来就是利⽤ IP 地址和服务器建⽴ TCP 连接。连接建⽴之后，浏览器端会构建请求⾏、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

   服务器接收到请求信息后，会根据请求信息⽣成响应数据（包括响应⾏、响应头和响应体等信息），并发给⽹络进程。等⽹络进程接收了响应⾏和响应头之后，就开始解析响应头的内容了。（为了⽅便讲述，下⾯我将服务器返回的响应头和响应⾏统称为响应头。）

- 重定向

  在接收到服务器返回的响应头后，⽹络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时⽹络进程会从响应头的 Location 字段⾥⾯读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，⼀切⼜重头开始了。

  在导航过程中，如果服务器响应⾏的状态码包含了 301、302 ⼀类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应⾏是 200，那么表⽰浏览器可以继续处理该请求。

- 响应数据类型处理

  在处理了跳转信息之后，我们继续导航流程的分析。URL 请求的数据类型，有时候是⼀个下载类型，有时候是正常的 HTML ⻚⾯，那么浏览器是如何区分它们呢？

  答案是 Content-Type。Content-Type 是 HTTP 头中⼀个⾮常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显⽰响应体的内容。

  如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进⾏导航流程。由于 Chrome 的⻚⾯渲染是运⾏在渲染进程中的，所以接下来就需要准备渲染进程了。

3. 准备渲染进程

   默认情况下，Chrome 会为每个⻚⾯分配⼀个渲染进程，也就是说，每打开⼀个新⻚⾯就会配套创建⼀个新的渲染进程。但是，也有⼀些例外，在某些情况下，浏览器会让多个⻚⾯直接运⾏在同⼀个渲染进程中。

   那什么情况下多个⻚⾯会同时运⾏在⼀个渲染进程中呢？

   Chrome 的默认策略是，每个标签对应⼀个渲染进程。但如果从⼀个⻚⾯打开了另⼀个新⻚⾯，⽽新⻚⾯和当前⻚⾯属于同⼀站点的话，那么新⻚⾯会复⽤⽗⻚⾯的渲染进程。官⽅把这个默认策略叫 process-persite-instance。

   - 通常情况下，打开新的⻚⾯都会使⽤单独的渲染进程；
   - 如果从 A ⻚⾯打开 B ⻚⾯，且 A 和 B 都属于同⼀站点的话，那么 B ⻚⾯复⽤ A ⻚⾯的渲染进程；如果是其他情况，浏览器进程则会为 B 创建⼀个新的渲染进程。

   渲染进程准备好之后，还不能⽴即进⼊⽂档解析状态，因为此时的⽂档数据还在⽹络进程中，并没有提交给渲染进程，所以下⼀步就进⼊了提交⽂档阶段。

4. 提交⽂档

   ⾸先要明确⼀点，这⾥的“⽂档”是指 URL 请求的响应体数据。

   - “提交⽂档”的消息是由浏览器进程发出的，渲染进程接收到“提交⽂档”的消息后，会和⽹络进程建⽴传输数据的“管道”。
   - 等⽂档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
   - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界⾯状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web ⻚⾯。

5. 渲染阶段

   ⼀旦⽂档被提交，渲染进程便开始⻚⾯解析和⼦资源加载了，关于这个阶段的完整过程，我会在下⼀篇⽂章中来专⻔介绍。这⾥你只需要先了解⼀旦⻚⾯⽣成完成，渲染进程会发送⼀个消息给浏览器进程，浏览器接收到消息后，会停⽌标签图标上的加载动画。
